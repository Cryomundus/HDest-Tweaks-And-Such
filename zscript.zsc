version "4.0"

class KeeperHandler : EventHandler
{
	override void PlayerDied(PlayerEvent e)
	{
		let plr = HDPlayerPawn(players[e.PlayerNumber].mo);
		if (plr)
		{
			let restorer = StatRestorer(plr.GiveInventoryType('StatRestorer'));
			if (restorer)
			{
//				restorer.OpenWounds = int(plr.woundcount * clamp(keeper_percent_bleeding, 0, 1.0));
//				restorer.UnstableWounds = int(plr.unstablewoundcount * clamp(keeper_percent_wounds, 0, 1.0));
//				restorer.TreatedWounds = int(plr.oldwoundcount * clamp(keeper_percent_wounds, 0, 1.0));
				restorer.Blues = int(plr.CountInv('HealingMagic') * clamp(keeper_percent_blues, 0, 1.0));
				restorer.Burns = int(plr.burncount * clamp(keeper_percent_burns, 0, 1.0));
				restorer.Aggro = int(plr.aggravateddamage * clamp(keeper_percent_aggro, 0, 1.0));
				restorer.Bloodloss = int(plr.bloodloss * clamp(keeper_percent_blood, 0, 1.0));

				Name diseaseClsName = 'DiseaseBase';
				if (keeper_percent_diseases > 0 && (class<Inventory>)(diseaseClsName))
				{
					for (Inventory next = plr.Inv; next != null; next = next.Inv)
					{
						if (next is diseaseClsName)
						{
							int amt = int(next.Amount * clamp(keeper_percent_diseases, 0, 1.0));
							if (amt > 0)
							{
								restorer.DiseaseClasses.Push(next.GetClass());
								restorer.DiseaseAmounts.Push(amt);
							}
						}
					}
				}
			}
		}
	}
}

// [Ace] Defer restoring stats a few tics later otherwise the player's OnRespawn virtual will clear everything you do in PlayerRespawned.
class StatRestorer : Inventory
{
	override void DoEffect()
	{
		let plr = HDPlayerPawn(owner);
		if (plr && plr.Health > 0 && ++AliveTicker > 2)
		{
//			plr.woundcount = OpenWounds;
//			plr.unstablewoundcount = UnstableWounds;
//			plr.oldwoundcount = TreatedWounds;
			plr.A_GiveInventory('HealingMagic', Blues);
			plr.aggravateddamage = Aggro;
			plr.burncount = Burns;
			plr.bloodloss = min(HDCONST_MAXBLOODLOSS, plr.bloodloss + Bloodloss); // [Ace] Add to PoF's bloodloss.

			for (int i = 0; i < DiseaseClasses.Size(); ++i)
			{
				plr.A_GiveInventory(DiseaseClasses[i], DiseaseAmounts[i]);
			}

			Destroy();
			return;
		}

		Super.DoEffect();
	}

	int AliveTicker;
	int Blues;
//	int OpenWounds, UnstableWounds, TreatedWounds;
	int Aggro;
	int Burns;
	int Bloodloss;

	Array<class<Inventory> > DiseaseClasses;
	Array<int> DiseaseAmounts;

	Default
	{
		Inventory.MaxAmount 1;
	}
}

class CleanHelmFrag:HDInvRandomSpawner{
	default{
		dropitem "ShellBoxPickup",96,2;
		dropitem "ShieldCore",100,2;
		dropitem "HDFragGrenades",72,1;
		dropitem "HD7mMag",48,1;
		dropitem "HD4mMag",48,1;
		dropitem "BFGNecroShard",96,1;
		dropitem "HDBattery",48,1;
		dropitem "PortableStimpack",48,1;
		dropitem "ClipBox",48,1;
		dropitem "HDAB",48,1;
	}
}
class CleanBlueFrag:HDInvRandomSpawner{
	default{
		dropitem "HD4mMag",96,2;
		dropitem "HDHealingPotion",96,2;
		dropitem "HDFragGrenades",72,1;
		dropitem "BFGNecroShard",96,1;
		dropitem "HD9mMag15",48,1;
		dropitem "HDBattery",72,1;
		dropitem "PortableMedikit",48,1;
		dropitem "PortableStimpack",48,1;
		dropitem "HDAB",48,1;
	}
}

// Bonus Cleanifier
class BonusCleaner : EventHandler
{
	private bool cvarsAvailable;
	private int spawnBiasActual;
	private bool isPersistent;
	void init()
	{
		cvarsAvailable = true;
		spawnBiasActual = bonus_clean_bias;
		isPersistent = bonus_persistent_spawning;
	}

	override void WorldLoaded(WorldEvent e)
	{
		init();
		super.WorldLoaded(e);
	}

	bool giverandom(int chance)
	{
		bool result = false;
		int iii = random(0, chance);
		if(iii < 0)
			iii = 0;
		if (iii == 0)
		{
			if(chance > -1)
				result = true;
		}
		
		return result;
	}

	void trycleanhelmfrag(worldevent e, int chance)
	{
		if(giverandom(chance))
		{
			let sss = CleanHelmFrag(e.thing.Spawn("CleanHelmFrag", e.thing.pos, SXF_TRANSFERSPECIAL | SXF_NOCHECKPOSITION));
			if(sss)
			{
				
				e.thing.destroy();
			}

		}
	}
	void trycleanbluefrag(worldevent e, int chance)
	{
		if(giverandom(chance))
		{
			let sss = CleanBlueFrag(e.thing.Spawn("CleanBlueFrag", e.thing.pos, SXF_TRANSFERSPECIAL | SXF_NOCHECKPOSITION));
			if(sss)
			{
				
				e.thing.destroy();
			}

		}
	}
override void worldthingspawned(worldevent e)
  {
	if(!cvarsAvailable)
		init();
	if(!e.Thing)
	{
		return;
	}
	if (!(level.maptime > 1) || isPersistent)
	{
		switch(e.Thing.GetClassName())
		{
			case 'BlueFrag':
				trycleanbluefrag(e, spawnBiasActual);
				break;
			case 'HelmFrag':
				trycleanhelmfrag(e, spawnBiasActual);
				break;
		}
	}
	}
}

// From HexaDoken.
class HDPurgeTheBarrelsPlease : Actor {
states{
	spawn:
		TNT1 A 0 nodelay {
			ThinkerIterator Purger = ThinkerIterator.Create("HDBarrel");
			Actor mo;
			int count=0;
			while (mo = HDBarrel(Purger.Next()))
				if (mo.health < 1) { mo.Destroy(); count++;} 
			if (count < 1) Console.Printf("No barrels to purge.");
			else if (count == 1) Console.Printf("Purged 1 barrel.");
			else Console.Printf("Purged %i barrels.", count);
		}
		stop;
	}
}

class HDBlueVulcFixHandler : EventHandler {
	Array<vulcanette> vulcs;
	Array<BlueSphere> balls; 
	
	override void WorldTick(){
		for (int i = balls.Size(); i > 0; i--)
			if (!balls[i-1])
				balls.Delete(i-1);

		for (int i = vulcs.Size(); i > 0; i--) {
			if (!vulcs[i-1]) {
				vulcs.Delete(i-1);
				continue;
			}
			if (vulcs[i-1].bmissile) {
				for (int ii = balls.Size(); ii > 0; ii--) {
					if (vulcs[i-1].Distance3D(balls[ii-1]) < 32.0) {
						if (balls[ii-1].bnointeraction) 
							continue;
						
						balls[ii-1].bnointeraction=true;
						PlantBit.SpawnPlants(balls[ii-1],70,144);
						balls[ii-1].setstatelabel("fadeout");
						vulcs[i-1].weaponstatus[14]=0;
						vulcs[i-1].weaponstatus[15]=0;
						break;
					}
				}
			}
		}
	}
	
	override void WorldThingSpawned(WorldEvent e){
		if (e.Thing) {
			if (e.Thing.GetClassName() == "vulcanette")
				vulcs.push(vulcanette(e.Thing));
			else if (e.Thing.GetClassName() == "BlueSphere" || e.Thing.GetClassName() == "BrownSphere")
				balls.push(BlueSphere(e.Thing));
		}
	}
}